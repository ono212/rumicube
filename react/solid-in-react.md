# [[번역] React에 SOLID 원칙 적용하기](https://dev-boku.tistory.com/entry/%EB%B2%88%EC%97%AD-React%EC%97%90-SOLID-%EC%9B%90%EC%B9%99-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0)

## 2023.04.26.next

SOLID원칙을 React에 어떻게 적용할 수 있을지 알아보자.

먼저 단일 책임 원칙(SRP)에 대해 알아볼게. 단일 책임 원칙은 “컴포넌트는 한 가지 작업을 수행해야 한다”는 원칙이야. 컴포넌트가 한 가지 작업을 수행하도록 적용하는 방법에는 1. 너무 많은 작업을 수행하는 큰 컴포넌트를 더 작은 컴포넌트로 나누기 2. 주요 컴포넌트 기능과 관련 없는 코드는 별도의 유틸리티 함수로 추출하기 3. 관련 있는 기능들은 커스텀 hook으로 캡슐화하기 의 방법이 있어.

예제 컴포넌트에 단일 책임 원칙을 적용해볼게. 현재 이 컴포넌트가 하고 있는 일은 데이터를 가져오고, 필터링해서, 목록의 각 항목을 렌더링하고 있어. 한 가지 일이 아니라 여러 일을 하고 있지. 먼저 user들의 데이터를 가져오고(`useEffect`) 상태로 관리(`useState`)하고 있는 코드들을 커스텀 hook(`useUsers`)으로 분리할 수 있어. 그래서 이제 `useUsers` hook의 일은 API로 user들의 데이터를 가져오는 일만 하고 있어. 이렇게 분리하면 뭐가 좋아?

메인 컴포넌트의 길이가 짧아지고 user데이터를 가져오는 일은 `useUsers`에서 하는 일이라는 걸 쉽게 파악할 수 있어.

두번째로 JSX부분에서 객체 배열을 순회하면서 `li`태그를 생성하고 있는데 `li`태그 안에 여러 태그가 있기 때문에, 이 부분을 별도의 컴포넌트로 추출해주는게 좋아. 왜 좋은데?

아까 한 말처럼 메인 컴포넌트의 길이가 짧아지면서 가독성이 좋아졌어.

세번째로 적용할 수 있는 부분은 비활성 사용자를 필터링하는 로직을 추출할 수 있어. 왜 그렇게 하는데?

다른 코드에서 충분히 재사용될 수 있는 로직이기 때문에 유틸리티 함수로 추출할거야.

이제 메인 컴포넌트가 되게 짧아지고 간단해진 것 같아. 하지만 여전히 메인 컴포넌트는 여러가지 일을 하고 있어. 데이터를 가져오고 필터링을 적용해서 렌더링하고 있지. 여기에서 더 개선시켜볼게. 메인 컴포넌트에서 필터링을 적용하는게 아니라 필터링이 적용된 데이터를 가져와서 보여주는 일만 한다면 더 좋을 것 같아. 그래서 새로운 커스텀 hook을 만들거야. `useUsers`로 데이터를 페칭한 후 필터링을 적용한 데이터를 반환하는 `useActiveUsers` hook을 만들었어. 이렇게 하니까 메인 컴포넌트의 일은 hook에게 받아온 데이터로 렌더링하는 일만 하게 됐어.

개방-폐쇄 원칙에 대해 알아볼게. “원본 코드를 변경하지 않고 확장할 수 있도록 컴포넌트를 구조화해야한다”는 원칙이야.

어떤 페이지냐에 따라 UI가 달라져야 하는 Header 컴포넌트를 예로 들어볼게. Header 컴포넌트 내부에서 분기 처리를 해서 페이지별로 다른 UI를 렌더링하도록 해결할 수도 있겠지? 하지만 이 방법은 페이지가 많아지면 많아질수록 Header 컴포넌의 코드를 수정해줘야해. Header 컴포넌트 내부에 분기 처리 로직을 계속 추가해야하지. 그래서 개방-폐쇄 원칙에 위배되는 해결책이라는 걸 알 수 있어.

그렇다면 해결책은 컴포넌트 합성이야. Header 컴포넌트 내부에서 어떻게 무엇을 렌더링할지를 신경쓰는게 아니라 Header컴포넌트를 사용하는 컴포넌트에게 신경쓰게 하는 거야. childeren prop을 사용해서 말이야! 이렇게 하면 아까의 해결방법처럼 새로운 페이지가 생길 때마다 Header 컴포넌트를 수정해주는게 아니라 사용하는 입장에서 해결할 수 있지.. 이렇게 컴포넌트 간의 결합을 줄이고 확장성과 재사용성을 높일 수 있어.

네번째 원칙은 인터페이스 분리 원칙(ISP)이야. “컴포넌트는 사용하지 않는 props에 의존해서는 안된다”는 원칙이야. 이 예제 코드에서 `Thumbnail` 컴포넌트는 문제가 있어. Video 객체를 Props로 받는데 Props중에서 실제로 내부에서 사용하고 있는 프로퍼티는 하나라는 점이야. 실제로 사용하는 프로퍼티보다 더 많은 프로퍼티들을 Props로 받고 있어. 그게 왜 문제야?

`Thumbnail` 컴포넌트를 재사용하고 싶을 때 Props를 Video객체의 형태로만 받아야하기 때문에 다른 객체일 때는 재사용할 수 없게 돼. 그래서 실제로 내부에서 사용하는 프로퍼티만 Props로 받도록 코드를 수정하면 재사용성을 높일 수 있어.

다섯번째 원칙은 의존관계 역전 원칙(DIP)이야. “어떤 컴포넌트(React 컴포넌트, 유틸리티 함수, 모듈 또는 서드파티 라이브러리 등)가 다른 컴포넌트에 직접적으로 의존하면 안되고, 둘 다 공통된 추상화에 의존해야 한다”는 원칙이야.

예제 코드에서 `LoginForm` 컴포넌트는 `api` 모듈을 직접 참조하므로 둘 사이는 긴밀히 결합되어 있다고 할 수 있어. 이러한 결합을 깨보도록 할게.

`api` 모듈을 직접 참조하는 방식이 아니라 props로 주입받도록 수정할거야. `onSubmit` 함수를 props로 받으면 돼. 이렇게 하면 `LoginForm` 컴포넌트는 이제 `api` 모듈에 의존하지 않아! `onSubmit` 콜백으로 추상화하면서 구체적인 코드의 구현은 `LoginForm` 컴포넌트를 사용하는 상위 컴포넌트의 책임이 되었어.

### 질문

Q1. 단일 책임 원칙 마지막 문단에서 다음 인용구가 어떤 뜻이야?

> 이제 "한 가지"를 어떻게 해석하는지에 따라 컴포넌트가 여전히 먼저 데이터를 얻은 다음 렌더링하기 때문에 "한 가지"가 아니라고 주장할 수 있습니다. 한 컴포넌트에서 hook을 호출한 다음 그 결과를 다른 컴포넌트에 props로 전달해서 더 나눌 수 있지만 실제 애플리케이션에서 이것이 실제로 이로운 경우는 거의 없었습니다. 때문에 정의를 "컴포넌트가 얻은 렌더링 데이터"를 "한 가지"로 너그럽게 받아들이도록 합시다.

단일 책임 원칙이라고 하면 하나의 모듈이 "한 가지" 책임만 수행해야 해. 그런데 리팩토링 한 이후의 코드도 누군가는 두 가지 일을 한다고 주장할 수도 있는데 그렇게 볼 필요 없이 하나로 보면 된다고 저자는 이야기하고 있어!

Q2. 여러 파트에서 말하는 다음 용어들이 잘 이해가 안 돼. 무슨 뜻이야?

> - 합성(composition)
> - 의존성
> - 결합도
>
> 합성이란
>
> - 컴포넌트가 다른 컴포넌트를 사용하는 걸 말해
> - 그런데 자식 컴포넌트는 일반적인 로직만 갖고 있어. 그리고 (자식 컴포넌트를 사용하는) 부모 컴포넌트가 구체적인 로직을 갖고 있어. 이때 부모 컴포넌트가 자식 컴포넌트를 사용할 때 자식 컴포넌트에게 구체적인 로직을 넘겨줘. 이런 방식으로 컴포넌트를 조합해서 사용하는 방식을 컴포넌트 합성이라고 해.
>
> 의존성이란
>
> A가 B에 의존하고 있다는 말은 B를 변경했을 때 A도 변경해야 하는 것을 뜻해. 즉 의존성이란 하나를 변경하면 다른 하나도 반드시 변경해야 하는 성질을 말하는거야.
>
> 결합도란
>
> 의존성과 똑같은 말이라고 생각하면 돼.
